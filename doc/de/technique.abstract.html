<HTML>

<HEAD>
    <META  http-equiv="Content-Type"      content="text/html; charset=UTF-8">
    <META  http-equiv="Content-Language"  content="de">
    <TITLE>roblet®.org - Technik - Übersicht</TITLE>
</HEAD>

<BODY>


<H1>Übersicht</H1>

<DIV  class="reference">
    <P>
        Ausführliche, konkretere und weiterführende Informationen zur
        Roblet®-Technik gibt das <A  href="technique.book.html">Buch</A>.
    </P>
    <P>
        Wollen Sie lieber gleich etwas "hacken", so können Sie auch sofort zum
        <A href="technique.sample.html">Beispiel</A> gehen.
    </P>
</DIV>

<P>
    Die Roblet®-Technik ist eine Client-Server-Architektur.&nbsp;
    Die nachfolgende Abbildung zeigt links die Client-Seite und rechts die
    Server-Seite:

    <CENTER>
        <IMG  src="technique.abstract.jpg"  border=1>
    </CENTER>
</P>

<P>
    Auf beiden Seiten ist die Basis eine beliebige Kombination aus Java™,
    einem Betriebssystem und einer Hardware.&nbsp;
    Dadurch sind extrem heterogene Landschaften überbrückbar.&nbsp;
    Dieser Ansatz ermöglicht überhaupt erst die im
    <A href="technique.preface.html">Vorwort</A> genannte
    <I>Verteilungsfreiheit</I>, <I>Technikvereinheitlichung</I>
    und <I>Netzwerktransparenz</I>.
</P>

<P>
    Beide Seiten verwenden auf Java™-Ebene als weitere gemeinsame Basis das
    <A href="../rdk/index.html">Roblet®-Development-Kit (RDK)</A>.&nbsp;
    Es stellt sämtliche benötigte Software für jede Seite bereit.&nbsp;
    Sie wird von uns betreut und ist frei verfügbar.
</P>


<H2>Server-Seite</H2>

<P>
    Auf der rechten Seite, d.h. der Server-Seite der Client-Server-Architektur,
    ist der <B>Roblet®-Server</B> mit den ihm zugeordneten <B>Modulen</B> 
    zu finden.&nbsp;
    Dabei ist der Roblet®-Server bis auf Versionsunterschiede prinzipiell immer
    der gleiche.&nbsp;
    Allein die zugeordneten Module entscheiden darüber, welche weitergehende
    Ressourcen der Roblet®-Server zusätzlich anbieten kann.&nbsp;
    Ein Roblet®-Server stellt sicher, daß Roblets® kontrolliert in einer
    "Sandbox" laufen, um Fehlverhalten verhindern zu können, und ermöglicht
    trotzdem den Ressourcen-Zugriff über sogenannte
    <A href="technique.abstract.units.html">Einheiten</A>.&nbsp;
    Auf diese Weise wird sichergestellt, daß der Server und die von ihm
    verwalteten Ressourcen nicht kompromitiert werden.&nbsp;
    Der Server kann in diesem Zusammenhang auch sicherstellen, daß im
    Fehlerfalle eine Ressource wieder in einen passenden Zustand gebracht
    wird.&nbsp;
    Ein Roblet®-Server kann mehrere Roblets® parallel ausführen.&nbsp;
    Er kann jedes Roblet® <U>jederzeit</U> beenden, wobei das Roblet®  hierbei
    keine Widerspruchsmöglichkeit hat.&nbsp;
    Abgrenzungsmechanismen sorgen dafür, daß im Falle eines abrupten Abbrechens
    eines Roblets® keine Ressourcen oder Bibliotheksteile in einem
    undefinierten Zustand zurückgelassen werden.&nbsp;
    Der Roblet®-Server ist Teil der Roblet®-Technik, wohingegen die Module
    separate Erweiterungen des Roblet®-Servers sind und von jedermann stammen
    können.
</P>


<H2>Klienten-Seite</H2>

<P>
    Auf der linken Seite, der Klienten-Seite, wird von der Roblet®-Anwendung
    die <B>Roblet®-Klient</B> eingesetzt.&nbsp;
    Diese Java™-Klasse ist das Tor zu allen Roblet®-Servern.&nbsp;
    Ihr Funktionsumfang beschränkt sich nicht nur auf die Kontaktierung von
    Servern und das Verschicken, Überwachen und gegebenenfalls Beenden von
    Roblets®.&nbsp;
    Stattdessen bietet sie umfangreiche weitere Funktionen, angefangen bei
    Hilfsmitteln zum Kommunizieren mit Roblets® bis hin zu Funktionen zum
    Auffinden ganz bestimmter Server mit Hilfe von
    <A href="technique.abstract.directories.html">Verzeichnissen</A>.&nbsp;
    Jegliche Datenübertragung wird im Falle eines Verbindungsabrisses
    automatisch und transparent wieder aufgebaut.&nbsp;
    Der Klient kümmert sich um alle Aspekte des definierten
    Kommunikationsverhaltens.&nbsp;
    Insgesamt ist der Klient der zentrale Baustein zur
    Verteilungsfreiheit und der Netzwerktransparenz der Roblet®-Technik.
</P>


<H2>Roblet®-Anwendung</H2>

<P>
    Eine <B>Roblet®-Anwendung</B> erstreckt sich mit Hilfe ihrer Roblets® über
    beide Seiten der Client-Server-Architektur.&nbsp;
    <B>Roblets</B> sind dabei einfach Anwendungsteile, die unter Kontrolle des
    Roblet®-Servers laufen und von der Anwendung zu diesem Zweck parametrisiert
    und mit Hilfe des Roblet®-Klienten zum Server geschickt wurden.&nbsp;
    Das Schicken erfolgt in Form eines Methodenaufrufes, der erst zurückkommt,
    wenn der Haupt-Thread des Roblets® endet.&nbsp;
    Dabei können auch Rückgabewerte des Roblets® zurückgegeben werden bzw. es
    werden Ausnahmen, die im Roblet® entstehen, an dieser Stelle (erneut)
    geworfen und können wie üblich bei Bedarf gefangen werden.&nbsp;
    Es müssen keinerlei separate "technikbrechende" Deployment-Mechanismen
    bemüht werden.&nbsp;
    Ein Roblet® läuft unabhängig von der sendenden Anwendung und läuft auch
    weiter, wenn die Kommunikation zur Anwendung unter- oder abgebrochen
    ist.&nbsp;
    Eine Anwendung kann mehrere verschiedene Roblets® gleichzeitig zu einem
    oder mehreren Servern schicken und parallel laufen lassen.&nbsp;
    Die Roblets® sind dabei das Hauptwerkzeug zur spezifischen
    Funktionalitätsverteilung und haben letztlich die große Verteilungsfreiheit
    zur Folge.&nbsp;
</P>


<H2>Ferne Instanzen</H2>

<P>
    Zusätzlich zur Möglichkeit, daß ein Roblet® quasi am Ende Werte zurückgibt,
    können auch zwischendurch Daten mit seiner Anwendung ausgetauscht
    werden.&nbsp;
    Dabei kann eine Roblet®-Anwendung vermittelt durch den Roblet®-Klienten
    mit Hilfe der <A name="remote"><B>fernen Instanzen</B></A> transparent auf
    Methoden speziell bestimmter Objekt-Instanzen zugreifen, die auf der
    jeweils anderen Seite existieren<SUP>1</SUP>.&nbsp;
    Für die zugreifende Seite macht sich nur eine mögliche Zeitverzögerung
    bemerkbar - der Rest geschieht automatisch<SUP>2</SUP>.&nbsp;
    Diese Form der Kommunikation ist bidirektional und in jede Richtung können
    parallel beliebig viele Datenströme fließen.
</P>


<HR>

<SUP>1</SUP>&nbsp;
<SMALL>
    ähnlich wie bei RPC, Corba, RMI oder Hessian, jedoch einfacher in der
    Handhabung
</SMALL>
<BR>
<SUP>2</SUP>&nbsp;
<SMALL>
    und anders als bei RPC, Corba, RMI und Hessian brauchen auch die nötigen
    Schnittstellen und deren Implementierungen nicht separat kompiliert oder
    gar manuell versioniert und verteilt werden
</SMALL>


</BODY>

</HTML>
